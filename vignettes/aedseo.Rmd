---
title: "Automated Detection of Seasonal Epidemic Onset and Burden Levels in R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Automated Detection of Seasonal Epidemic Onset and Burden Levels in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, message=FALSE}
library(aedseo)
```

## Introduction

This function performs automated and early detection of seasonal epidemic onsets and calculates the burden levels from time series dataset stratified by season.
The seasonal onset estimates growth rates for consecutive time intervals and calculates the sum of cases.
The burden levels use the previous seasons to calculate the levels of the current season.
The algorithm allows for surveillance of pathogens, by alarming when the observations increase significantly in the selected time interval and based on the
disease specific threshold, while also evaluating the burden of current rates based on previous seasons.

## Generate seasonal data

To apply the aedseo algorithm, data needs to be transformed into a `tsd` object.
If you have your own data the `to_time_series()` function can be used with the arguments `observation`, `time`, `time_interval`.
In the following section, the application of the algorithm is done with simulated data created with the `generate_seasonal_data()` function.
More information about the function can be found in the `vignette("generate_seasonal_wave)`

```{r}
# Construct an 'tsd' object with time series data
set.seed(222)
tsd_data <- generate_seasonal_data(
  years = 3,
  start_date = as.Date("2021-10-18"),
  amplitude = 2000,
  phase = 0,
  trend_rate = 1.001,
  noise_sd = 100,
  time_interval = "week"
)
```

In the following figure, the simulated data (solid circles) is visualized alongside the mean (solid line) for the three arbitrary years of weekly data.

```{r}
# Have a glance at the time varying mean and the simulated data
plot(tsd_data)
```

# Determining season
Respiratory viruses can circulate in different seasons based on the location.
In the nordic hemisphere they mostly circulate in the fall and winter seasons, hence surveillance is intensified from week 40 to week 20 in the following year.
To include all data the season in the example is set from week 21 to week 20 in the following year.

# Determining the disease specific threshold
The disease specific threshold can be determined by examining observations for the pathogen from previous seasons,
and determine at what number of observations the rate suddenly increases drastically.

In this example the disease specific threshold is determined based on consecutive significant observations from all available previous seasons.
Significant observations are defined as those with a significant positive growth rate (a positive lower growth rate).

To capturing short-term changes and fluctuations in the data, a rolling window of size $k = 5$ is used to create subsets of the data for model fitting,
and the `quasipoisson` family is used to accound for overdispersion.

The `seasonal_onset()` function is used for this purpose, without adding the disease threshold.
```{r}
growth_warning_algo <- seasonal_onset(
  tsd = tsd_data,
  k = 5,
  family = "quasipoisson",
  season_start = 21,
  season_end = 20,
  only_current_season = FALSE
)

significant_vs_obs <- growth_warning_algo |>
  dplyr::mutate(
    Counter = cumsum(growth_warning == TRUE & !is.na(growth_warning)) * growth_warning
  ) |>
  dplyr::mutate(Counter = dplyr::if_else(growth_warning, Counter, NA)) |>
  # Identify where NA occurs in the Counter column
  dplyr::mutate(
    ChangeFlag = is.na(Counter),
    GroupID = cumsum(ChangeFlag)  # Make a Group for each NA
  ) |>
  dplyr::ungroup() |>
  dplyr::group_by(GroupID) |>
  dplyr::mutate(
    SequentialCounter = dplyr::if_else(
      growth_warning == TRUE, # Increment of numbers for Significant == TRUE
      rev(cumsum(rev(!is.na(Counter)))), NA # Reverse numbers for visuality on plot
    )
  ) |>
  dplyr::ungroup()

significant_vs_obs$season <- factor(
  significant_vs_obs$season,
  levels = sort(unique(significant_vs_obs$season), decreasing = FALSE, method = "auto")
)

significant_vs_obs |>
  dplyr::filter(!is.na(SequentialCounter)) |>
  ggplot2::ggplot(mapping = ggplot2::aes(x = sum_of_cases)) +
  ggplot2::geom_line(
    mapping = ggplot2::aes(
      y = SequentialCounter,
      group = GroupID,
      linetype = "Consecutive Weeks",
      color = season
    )
  ) +
  ggplot2::scale_color_manual(
    values = c("#ebac23", "#006e00", "#008cf9", "#b80058"),
    breaks = unique(significant_vs_obs$season),
    labels = unique(significant_vs_obs$season)
  ) +
  ggplot2::scale_x_log10() +
  ggplot2::labs(
    y = "Number of significant observations",
    linetype = "",
    x = "Rolling sum of positive cases (5 weeks)"
  ) +
  ggplot2::guides(linetype = "none") +
  ggplot2::theme_bw()
```
Inspect the exact numbers of when the significant observations for each season starts
Since the threshold that has to be exceeded is in a window of 5 weeks, the sum of cases where the significant
observations start has to be divided with 5 to find the disease specific threshold for one time step.
```{r}
significant_vs_obs |>
  dplyr::filter(!is.na(SequentialCounter)) |>
  dplyr::group_by(season) |>
  dplyr::filter(SequentialCounter == max(SequentialCounter)) |>
  dplyr::mutate(disease_threshold = sum_of_cases / 5,
                week = ISOweek::ISOweek(reference_time)) |>
  dplyr::select(season, week, disease_threshold)
```

By inspecting the output from the above code, we see that the first season starts very late compared to the subsequent seasons,
which can also be observed on the plot of the data above. Due to this we select the disease specific threshold based on the
complete seasons; 2022/2023 - 2024/2025, and based on this the disease specific threshold is set to 150.

## Applying the main algorithm

```{r}
seasonal_output <- combined_seasonal_output(tsd = tsd_data, disease_threshold = 150)
```
