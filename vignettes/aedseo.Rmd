---
title: "Automated Detection of Seasonal Epidemic Onset and Burden Levels in R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Automated Detection of Seasonal Epidemic Onset and Burden Levels in R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning=FALSE, message=FALSE}
library(aedseo)
```

## Introduction

This function performs automated and early detection of seasonal epidemic onsets and calculates the burden levels from time series dataset stratified by season.
The seasonal onset estimates growth rates for consecutive time intervals and calculates the sum of cases.
The burden levels use the previous seasons to calculate the levels of the current season.
The algorithm allows for surveillance of pathogens, by alarming when the observations increase significantly in the selected time interval and based on the
disease specific threshold, while also evaluating the burden of current rates based on previous seasons.

## Generate seasonal data

To apply the `aedseo` algorithm, data needs to be transformed into a `tsd` object.
If you have your own data, the `to_time_series()` function can be used with the arguments: `observation`, `time`, `time_interval`.
In the following section, the application of the algorithm is shown with simulated data created with the `generate_seasonal_data()` function.
More information about the function can be found in the `vignette("generate_seasonal_wave")`

```{r, include = FALSE}
withr::local_seed(222)
# Construct an 'tsd' object with time series data
set.seed(222)
tsd_data <- generate_seasonal_data(
  years = 3,
  start_date = as.Date("2021-10-18"),
  amplitude = 2000,
  phase = 0,
  trend_rate = 1.001,
  noise_sd = 100,
  time_interval = "week"
)
```

In the following figure, the simulated data (solid circles) is visualized alongside the mean (solid line) for the three arbitrary years of weekly data.

```{r}
# Have a glance at the time varying mean and the simulated data
plot(tsd_data)
```

# Determining season
Respiratory viruses can circulate in different seasons based on the location.
In the nordic hemisphere they mostly circulate in the fall and winter seasons, hence surveillance is intensified from week 40 to week 20 in the following year.
To include all data the season in the example is set from week 21 to week 20 in the following year.

# Determining the disease specific threshold
The disease specific threshold can be determined by examining seasonal observations for the pathogen from previous seasons,
and determine at what number of observations the rate suddenly increases drastically.

In this example the disease specific threshold is determined based on consecutive significant observations from all available previous seasons.
Significant observations are defined as those with a significant positive growth rate (a positive lower growth rate).

To capturing short-term changes and fluctuations in the data, a rolling window of size $k = 5$ is used to create subsets of the data for model fitting,
and the `quasipoisson` family is used to accound for overdispersion.

The `seasonal_onset()` function is used for this purpose, without adding the disease threshold.
```{r}
growth_warning_algo <- seasonal_onset(
  tsd = tsd_data,
  k = 5,
  family = "quasipoisson",
  na_fraction_allowed = 0.4,
  season_start = 21, # Season starts in week 21
  season_end = 20, # Season ends in week 20 the following year
  only_current_season = FALSE
)

significant_vs_obs <- growth_warning_algo |>
  dplyr::mutate(
    Counter = cumsum(growth_warning == TRUE & !is.na(growth_warning)) * growth_warning
  ) |>
  dplyr::mutate(Counter = dplyr::if_else(growth_warning, Counter, NA)) |>
  # Identify where NA occurs in the Counter column
  dplyr::mutate(
    ChangeFlag = is.na(Counter),
    GroupID = cumsum(ChangeFlag)  # Make a Group for each NA
  ) |>
  dplyr::ungroup() |>
  dplyr::group_by(GroupID) |>
  dplyr::mutate(
    SequentialCounter = dplyr::if_else(
      growth_warning == TRUE, # Increment of numbers for Significant == TRUE
      rev(cumsum(rev(!is.na(Counter)))), NA # Reverse numbers for visuality on plot
    )
  ) |>
  dplyr::ungroup()

significant_vs_obs$season <- factor(
  significant_vs_obs$season,
  levels = sort(unique(significant_vs_obs$season), decreasing = FALSE, method = "auto")
)

significant_vs_obs |>
  dplyr::filter(!is.na(SequentialCounter)) |>
  ggplot2::ggplot(mapping = ggplot2::aes(x = sum_of_cases)) +
  ggplot2::geom_line(
    mapping = ggplot2::aes(
      y = SequentialCounter,
      group = GroupID,
      linetype = "Consecutive Weeks",
      color = season
    )
  ) +
  ggplot2::scale_color_manual(
    values = c("#ebac23", "#006e00", "#008cf9", "#b80058"),
    breaks = unique(significant_vs_obs$season),
    labels = unique(significant_vs_obs$season)
  ) +
  ggplot2::scale_x_log10(
    breaks = scales::log_breaks(base = 10, n = 10),
    labels = scales::label_comma()
  ) +
  ggplot2::labs(
    y = "Number of significant observations",
    linetype = "",
    x = "Rolling sum of positive cases (5 weeks)"
  ) +
  ggplot2::guides(linetype = "none") +
  ggplot2::theme_bw()
```
Since the threshold that has to be exceeded is in a window of 5 weeks, the sum of cases where the significant
observations start has to be divided with 5 to find the disease specific threshold for one time step.

Observing the plot the significant growth rate starts at around 700 observations, hence the disease specific threshold
would be $\frac{700}{5} = 140$.

Inspect the exact numbers of when the significant observations for each season starts
```{r}
significant_vs_obs |>
  dplyr::filter(!is.na(SequentialCounter)) |>
  dplyr::group_by(season) |>
  dplyr::filter(SequentialCounter == max(SequentialCounter)) |>
  dplyr::mutate(disease_threshold = sum_of_cases / 5,
                week = ISOweek::ISOweek(reference_time)) |>
  dplyr::select(season, week, disease_threshold)
```

By inspecting the output from the above code, we see that the first season starts very late compared to the subsequent seasons,
which can also be observed on the plot of the data above. Due to this we select the disease specific threshold based on the
complete seasons; 2022/2023 - 2024/2025, hence the disease specific threshold is set to 140.

## Applying the main algorithm

```{r}
seasonal_output <- combined_seasonal_output(
  tsd = tsd_data,
  disease_threshold = 140
)
```

```{r}
disease_threshold <- 140
# Adjust y_lower_bound dynamically
y_lower_bound <- ifelse(disease_threshold < 10, 1, 5)

#plot(x = seasonal_output,
#                    y_lower_bound = y_lower_bound,
#                    time_interval = "3 weeks",
#                    legend_position = "bottom")
```
